\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage[utf8]{inputenc}
\usepackage[greek, english]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{hhline}
\usepackage{alphabeta}
\usepackage{lmodern}
\usepackage[margin = 2.5cm, paperwidth=8.5in, paperheight=11in]{geometry}
\usepackage{graphicx, wrapfig}
\usepackage{minted}


\begin{document}
\begin{wrapfigure}[5]{l}{0.2\textwidth}
\includegraphics[scale=0.11]{pyrforos.png}
\end{wrapfigure} 
\noindent
Εθνικό Μετσόβιο Πολυτεχνείο\\
Σχολή Ηλεκτρολόγων Μηχανικών και Μηχανικών Υπολογιστών\\
Τομέας Τεχνολογίας Πληροφορικής και Υπολογιστών\\
\textbf{Εργαστήριο Μικροϋπολογιστών}\\
Χειμερινό Εξάμηνο 2021-2022\\
\vspace{2.5cm}
\vspace{-5em}
\hrule \vspace{.2em}
\hrule
\vspace{1cm}
\centering
{\Large \textbf{4η Εργαστηριακή Άσκηση}\\ \textbf{Ηλεκτρονική κλειδαριά με αισθητήρα CO}\\}
\vspace{0.2cm}
\raggedright
$~~~~$\\
Μέλος 1: Λαγός Αναστάσιος - 03113531\\
Μέλος 2: Αντώνιος Δημήτριος Αλικάρης - 03118062 \\

\section*{1. Assembly}

\subsection*{Σημειώσεις}
Οι ρουτινές εξυπηρέτησης των διακοπών του ADC και του timer1 υλοποιήθηκαν έτσι ώστε να μεταβάλλουν και να αποθηκεύουν μόνο την κατάσταση των LEDs αερίου, χωρίς να δίνουν έξοδο στα LEDs. Αυτή η έξοδος γίνεται στην κύρια ρουτίνα.\\
Κατά τον συναγερμό ($>$70ppm) τα LEDs αερίου πρέπει να αναβοσβήνουν. Αυτό υλοποιήθηκε με την βοήθεια του T flag του SREG, του οποίου η τιμή γίνεται 0x00$\rightarrow$ 0x01 ή 0x01$\rightarrow$ 0x00 κάθε 100ms.
Κατά την πληκτρολόγηση λάθους κωδικού, η χρονοκαθυστέρηση έχει χωριστεί ως εξής: $$4\times(0.1\times 5 + 0.1\times 5)$$ Έτσι κάθε 100ms που έχουμε καινούργια έξοδο από τον ADC, η τιμή αυτή ανανεώνεται στα LEDs.

\subsection*{Κώδικας}

\begin{minted}[linenos,frame=single,breaklines=true]{asm}

.DSEG
_tmp_:.byte 2

.DEF temp = r16	;used for cpc instruction
.DEF clear_lcd = r17 ;indicates if the message "CLEAR" is on the LCD (clear_lcd == 0x01) or not (clear_lcd == 0x00)
.DEF gas_led = r18 ;stores the states of the gas_leds (PB0-PB6). We divided 1024(maximum number the ADC can read) by 8 = 128. That means 128 gas levels. With the first (<128) being all gas_leds off.
.DEF gas_detected = r19 ;indicates if the message "GAS DETECTED" is on the LCD (gas_detected == 0x01) or not (gas_detected == 0x00)

.CSEG
.include "m16def.inc"
;Define RESET,TIMER1 overflow and ADC routines
.org 0x00
rjmp main
.org 0x10
rjmp ISR_TIMER1_OVF
.org 0x1C
rjmp ISR_ADC

main:
	ldi r24, low(RAMEND)	;Initialize stack pointer
	out SPL, r24
	ldi r24, high(RAMEND)   ;RAMEND is defined in m16def.inc
	out SPH, r24

	clr temp
	clr clear_lcd
	clr gas_led
	clr gas_detected
	clr r28
	clr r20
	clr r21
	;T flag of SREG is used for flicking the gas leds
	clt

	ldi r24, (1 << PC7)|(1 << PC6)|(1 << PC5)|(1 << PC4)	;Initialize 4 MSB of PORTC as outputs
	out DDRC, r24

	ser r24
	out DDRB, r24			;Initialize LEDs
	out DDRD, r24			;Initialize PORTD(LCD) as output

	rcall ADC_init			;Initialize ADC
	rcall TCNT1_init		;Initialize timer1

	clr r24
	rcall lcd_init_sim		;Clear LCD

	sei						;Enable global interrupts

	first_button:
		rcall scan_keypad_rising_edge_sim
        mov r22, r24
        or r22, r25
		cpi r22, 0
		;The cpu spends most of the time in this code block therefore we output any changes to the gas LEDs states performed by the ADC interrupt.
		out PORTB, gas_led

		breq first_button
    first_ascii:
		rcall keypad_to_ascii_sim	;Convert to ASCII for comparison
		mov r20, r24		;first button

	second_button:
		rcall scan_keypad_rising_edge_sim
        mov r22, r24
        or r22, r25
        cpi r22, 0
		;The cpu might spend some time in this code block therefore we output any changes to the gas LEDs states performed by the ADC interrupt.
		out PORTB, gas_led

		breq second_button
    second_ascii:
		rcall keypad_to_ascii_sim	;Convert to ASCII for comparison
		mov r21, r24		;second button

	check:	;Check if the input code is correct. For our team, that's "71"
		cpi r20, '7'
		brne wrong
        cpi r21, '1'
        brne wrong
		;Past this point we have a correct password
	correct:
		cli					;Stop global interrupts. We don't want any of the gas detection features during this part

        rcall lcd_init_sim	;Clear LCD

        ldi r24, 'W'
        rcall lcd_data_sim
        ldi r24, 'E'
        rcall lcd_data_sim
        ldi r24, 'L'
        rcall lcd_data_sim
        ldi r24, 'C'
        rcall lcd_data_sim
        ldi r24, 'O'
        rcall lcd_data_sim
        ldi r24, 'M'
        rcall lcd_data_sim
        ldi r24, 'E'
        rcall lcd_data_sim

        rcall scan_keypad_rising_edge_sim   ;for successful remote operation

		ldi r24, 0x80		;Light up
			
		out PORTB, r24		;the MSB of leds PB
			
		ldi r24, low(4000)
		ldi r25, high(4000)
		rcall wait_msec		;Wait for 4 secs

		clr r24				;Turn off
		out PORTB, r24		;the MSB of leds PB
		rcall lcd_init_sim	;Clear "WELCOME"
		clr gas_detected	;LCD is empty therefore this should be 0x00
		clr clear_lcd		;LCD is empty therefore this should be 0x00
		sei					;Enable global interrupts again
		jmp first_button
		
	wrong:
        rcall scan_keypad_rising_edge_sim   ;for successful remote operation

		ldi r24,4			;Number of loops
    wrong_loop:				;4 loops of 0.5 sec off 0.5 on
		push r24			;Save number of loops
		;TURN ON
		ldi r24, 0x80
		or r24, gas_led		;Get state of gas leds
		out PORTB, r24		;Output to leds, both MSB and gas
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		ldi r24, 0x80
		or r24, gas_led		;Get state of gas leds
		out PORTB, r24		;Output to leds, both MSB and gas
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		ldi r24, 0x80
		or r24, gas_led		;Get state of gas leds
		out PORTB, r24		;Output to leds, both MSB and gas
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		ldi r24, 0x80
		or r24, gas_led		;Get state of gas leds
		out PORTB, r24		;Output to leds, both MSB and gas
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		ldi r24, 0x80
		or r24, gas_led		;Get state of gas leds
		out PORTB, r24		;Output to leds, both MSB and gas
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec
		;TURN OFF
		mov r24, gas_led
		out PORTB, r24
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		mov r24, gas_led
		out PORTB, r24
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		mov r24, gas_led
		out PORTB, r24
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		mov r24, gas_led
		out PORTB, r24
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		mov r24, gas_led
		out PORTB, r24
		ldi r24, low(100)
		ldi r25, high(100)
		rcall wait_msec		;Wait 0.1 sec

		mov r24, gas_led
		out PORTB, r24

		pop r24
		subi r24, 1			;Subtract one loop
		brne wrong_loop


	jmp first_button

	wait_msec:
		push r24
		push r25
		ldi r24, low(1000)
		ldi r25, high(1000)
		rcall wait_usec
		pop r25
		pop r24
		sbiw r24, 1
		brne wait_msec

		ret

	wait_usec:
		sbiw r24, 1 ;2 cycles
		nop
		nop
		nop
		nop
		brne wait_usec ;1 cycle the majority of the time

		ret
	;ADC initialization routine
	ADC_init:
		ldi r24, (1 << REFS0)	;Vcc = 5V
		out ADMUX, r24

		ldi r24, (1 << ADEN) | (1 << ADIE) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0)	;Enable ADC, Enable ADC interrupts, prescaler = 128
		out ADCSRA, r24
		ret
	;TIMER1 initialization routine
	TCNT1_init:
		ldi r24, (1 << TOIE1)	;Enable interrupts for timer1
		out TIMSK, r24

		ldi r24, (1 << CS12) | (0 << CS11) | (1 << CS10)	;Set prescaler at 1024.
		out TCCR1B, r24

		;Clock at 8MHz
		;8MHz / 1024(prescale) = 7812.5Hz
		;Interrupt every 100ms | interrupt every 0.1 * 7812.5 = 781.25 cycles
		;Overflow happens at 65536 cycles. Therefore start counting from 65536 - 781.25 = 64755 = 0xFCF3
		ldi r24, 0xFC
		out TCNT1H, r24
		ldi r24, 0xF3
		out TCNT1L, r24

		ret
	;TIMER1 overflow ISR
	ISR_TIMER1_OVF:
		push r24
		;Here we implement the gas LEDs flickering if the alarm is on. The T flag of SREG is used for determining whether the gas LEDs should be on/off(T flag = 0x00/0x01) for the next 100ms.
		cpi r28, 0x01	;r28 is indicative of whether the alarm (over 70ppm) is on or off (0x01, 0x00)
		brne continue_1	;If the alarm is off, set T and continue with ISR
		;If the alarm is on then
		brtc continue_1	;If T was clear(gas_leds off) then they should be ON for the next 100ms
		clt	;If T was set (gas_leds on) then they should be OFF for the next 100ms.
		jmp continue_2

	continue_1:
		set
	continue_2:
		in r24, SREG	;Of course with have to save the state of SREG after we modify T.
		push r24
		ldi r24, (1 << CS12) | (0 << CS11) | (1 << CS10)
		out TCCR1B, r24

		ldi r24, 0xFC			;Initialize counter at 64755
		out TCNT1H, r24
		ldi r24, 0xF3
		out TCNT1L, r24

		in r24, ADCSRA
		ori r24, (1 << ADSC)	;Start AD Conversion
		out ADCSRA, r24

		pop r24					;restore SREG and r24
		out SREG, r24
		pop r24

		reti

	ISR_ADC:
		push r25
		push r24
		in r24, SREG
		push r24

		in r24, ADCL			;r24,r25 store the output of the ADC
		in r25, ADCH

		cpi r24, 0x80			; adc < 128
		cpc r25, r1	
		brcs long_jump_under_128;Too far for relative jump

		cpi r24, 0xCD
		cpc r25, r1				; adc < 205 (70ppm)
		brcs long_jump_under_205
		;This code is over 70ppm
		ldi r28, 0x01			;Alarm is on

		brts continue_adc		;If T is set then just calculate the new gas_led state. 
		clr gas_led				;Else, a cleared T indicates that the gas_leds should be off
		jmp ISR_ADC_EXIT		;So exit the ISR
	long_jump_under_128:
		jmp under_128
	long_jump_under_205:
		jmp under_205 
	continue_adc:
		cpi gas_detected, 0x01	;If "GAS DETECTED" message is on LCD, no need to show it again
		breq dont_show_LCD
		;If not on LCD then show it
		rcall lcd_init_sim		; Clear LCD

		ldi r24, 'G' 
		rcall lcd_data_sim
		ldi r24, 'A'
		rcall lcd_data_sim
		ldi r24, 'S'
		rcall lcd_data_sim
		ldi r24, ' '
		rcall lcd_data_sim
		ldi r24, 'D'
		rcall lcd_data_sim
		ldi r24, 'E'
		rcall lcd_data_sim
		ldi r24, 'T'
		rcall lcd_data_sim
		ldi r24, 'E'
		rcall lcd_data_sim
		ldi r24, 'C'
		rcall lcd_data_sim
		ldi r24, 'T'
		rcall lcd_data_sim
		ldi r24, 'E'
		rcall lcd_data_sim
		ldi r24, 'D'
		rcall lcd_data_sim

		ldi gas_detected, 0x01	;"GAS DETECTED" on LCD, dont come back here unless its off!
		clr clear_lcd			;"CLEAR" is not on LCD.
	dont_show_LCD:

		cp r24, r1				; adc < 256
		ldi temp, 0x01
		cpc r25, temp
		brcs under_256

		cpi r24, 0x80			; adc < 384
		ldi temp, 0x01
		cpc r25, temp
		brcs under_384

		cp r24, r1				; adc < 512
		ldi temp, 0x02
		cpc r25, temp
		brcs under_512

		cpi r24, 0x01			; adc < 640
		ldi temp, 0x02
		cpc r25, temp
		brcs under_640

		cp r24, r1				; adc < 768
		ldi temp, 0x03
		cpc r25, temp
		brcs under_768

		cpi r24, 0x01			; adc < 896
		ldi temp, 0x03
		cpc r25, temp		
		brcs under_896

		ldi gas_led, 0x7F
		jmp ISR_ADC_EXIT
	under_128:
		clr r28
		cpi clear_lcd, 0x01		;If "CLEAR" message is on LCD, no need to show it again
		breq dont_show_clear_128

		rcall lcd_init_sim		; Clear LCD

		ldi r24, 'C' 
		rcall lcd_data_sim
		ldi r24, 'L'
		rcall lcd_data_sim
		ldi r24, 'E'
		rcall lcd_data_sim
		ldi r24, 'A'
		rcall lcd_data_sim
		ldi r24, 'R'
		rcall lcd_data_sim

		ldi clear_lcd, 0x01		;"CLEAR" on LCD, dont come back here unless its off!

	dont_show_clear_128:
		clr gas_detected		;"GAS DETECTED" is not on LCD.
		clr gas_led
		jmp ISR_ADC_EXIT

	under_205:
		clr r28
		cpi clear_lcd, 0x01
		breq dont_show_clear_205

		rcall lcd_init_sim		; Clear LCD

		ldi r24, 'C' 
		rcall lcd_data_sim
		ldi r24, 'L'
		rcall lcd_data_sim
		ldi r24, 'E'
		rcall lcd_data_sim
		ldi r24, 'A'
		rcall lcd_data_sim
		ldi r24, 'R'
		rcall lcd_data_sim

		ldi clear_lcd, 0x01

	dont_show_clear_205:
		clr gas_detected
		ldi gas_led, 0x01
		jmp ISR_ADC_EXIT

	under_256:
		ldi gas_led, 0x01
		jmp ISR_ADC_EXIT

	under_384:
		ldi gas_led, 0x03
		jmp ISR_ADC_EXIT

	under_512:
		ldi gas_led, 0x07
		jmp ISR_ADC_EXIT

	under_640:
		ldi gas_led, 0x0F
		jmp ISR_ADC_EXIT

	under_768:
		ldi gas_led, 0x1F
		jmp ISR_ADC_EXIT
		
	under_896:
		ldi gas_led, 0x3F

	ISR_ADC_EXIT:
		pop r24
		out SREG, r24
		pop r24
		pop r25

		reti
			

	scan_row_sim:
        out PORTC, r25 ; ? ?????????? ?????? ??????? ??? ?????? ‘1’
        push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
        push r25 ; ?????????? ??? ???????????? ??????????????
        ldi r24,low(500) ; ?????????
        ldi r25,high(500)
        rcall wait_usec
        pop r25
        pop r24 ; ????? ????? ??????
        nop
        nop ; ??????????? ??? ?? ???????? ?? ????? ? ?????? ??????????
        in r24, PINC ; ??????????? ?? ?????? (??????) ??? ????????? ??? ????? ?????????
        andi r24 ,0x0f ; ????????????? ?? 4 LSB ???? ?? ‘1’ ???????? ??? ????? ?????????
        ret ; ?? ?????????

	scan_keypad_sim:
        push r26 ; ?????????? ???? ??????????? r27:r26 ????? ????
        push r27 ; ????????? ???? ???? ???????
        ldi r25 , 0x10 ; ?????? ??? ????? ?????? ??? ????????????? (PC4: 1 2 3 A)
        rcall scan_row_sim
        swap r24 ; ?????????? ?? ??????????
        mov r27, r24 ; ??? 4 msb ??? r27
        ldi r25 ,0x20 ; ?????? ?? ??????? ?????? ??? ????????????? (PC5: 4 5 6 B)
        rcall scan_row_sim
        add r27, r24 ; ?????????? ?? ?????????? ??? 4 lsb ??? r27
        ldi r25 , 0x40 ; ?????? ??? ????? ?????? ??? ????????????? (PC6: 7 8 9 C)
        rcall scan_row_sim
        swap r24 ; ?????????? ?? ??????????
        mov r26, r24 ; ??? 4 msb ??? r26
        ldi r25 ,0x80 ; ?????? ??? ??????? ?????? ??? ????????????? (PC7: * 0 # D)
        rcall scan_row_sim
        add r26, r24 ; ?????????? ?? ?????????? ??? 4 lsb ??? r26
        movw r24, r26 ; ???????? ?? ?????????? ????? ??????????? r25:r24
        clr r26 ; ?????????? ??? ??? ????????????? ????????
        out PORTC,r26 ; ?????????? ??? ??? ????????????? ????????
        pop r27 ; ????????? ???? ??????????? r27:r26
        pop r26
        ret

	scan_keypad_rising_edge_sim:
        push r22 ; ?????????? ???? ??????????? r23:r22 ??? ????
        push r23 ; r26:r27 ????? ???? ????????? ???? ???? ???????
        push r26
        push r27
        rcall scan_keypad_sim ; ?????? ?? ???????????? ??? ?????????? ?????????
        push r24 ; ??? ?????????? ?? ??????????
        push r25
        ldi r24 ,15 ; ??????????? 15 ms (??????? ????? 10-20 msec ??? ??????????? ??? ???
        ldi r25 ,0 ; ???????????? ??? ????????????? – ????????????? ????????????)
        rcall wait_msec
        rcall scan_keypad_sim ; ?????? ?? ???????????? ???? ??? ????????
        pop r23 ; ??? ??????? ?????????? ???????????
        pop r22
        and r24 ,r22
        and r25 ,r23
        ldi r26 ,low(_tmp_) ; ??????? ??? ????????? ??? ????????? ????
        ldi r27 ,high(_tmp_) ; ??????????? ????? ??? ???????? ????? r27:r26
        ld r23 ,X+
        ld r22 ,X
        st X ,r24 ; ?????????? ??? RAM ?? ??? ?????????
        st -X ,r25 ; ??? ?????????
        com r23
        com r22 ; ???? ???? ????????? ??? ????? «?????» ???????
        and r24 ,r22
        and r25 ,r23
        pop r27 ; ????????? ???? ??????????? r27:r26
        pop r26 ; ??? r23:r22
        pop r23
        pop r22
        ret 

	keypad_to_ascii_sim:
        push r26 ; ?????????? ???? ??????????? r27:r26 ????? ????
        push r27 ; ????????? ???? ??? ???????
        movw r26 ,r24 ; ?????? ‘1’ ???? ?????? ??? ?????????? r26 ????????
        ; ?? ???????? ??????? ??? ????????
        ldi r24 ,'*'
        ; r26
        ;C 9 8 7 D # 0 *
        sbrc r26 ,0
        rjmp return_ascii
        ldi r24 ,'0'
        sbrc r26 ,1
        rjmp return_ascii
        ldi r24 ,'#'
        sbrc r26 ,2
        rjmp return_ascii
        ldi r24 ,'D'
        sbrc r26 ,3 ; ?? ??? ????? ‘1’??????????? ??? ret, ?????? (?? ????? ‘1’)
        rjmp return_ascii ; ?????????? ?? ??? ?????????? r24 ??? ASCII ???? ??? D.
        ldi r24 ,'7'
        sbrc r26 ,4
        rjmp return_ascii
        ldi r24 ,'8'
        sbrc r26 ,5
        rjmp return_ascii
        ldi r24 ,'9'
        sbrc r26 ,6
        rjmp return_ascii ;
        ldi r24 ,'C'
        sbrc r26 ,7
        rjmp return_ascii
        ldi r24 ,'4' ; ?????? ‘1’ ???? ?????? ??? ?????????? r27 ????????
        sbrc r27 ,0 ; ?? ???????? ??????? ??? ????????
        rjmp return_ascii
        ldi r24 ,'5'
        ;r27
        ;? 3 2 1 B 6 5 4
        sbrc r27 ,1
        rjmp return_ascii
        ldi r24 ,'6'
        sbrc r27 ,2
        rjmp return_ascii
        ldi r24 ,'B'
        sbrc r27 ,3
        rjmp return_ascii
        ldi r24 ,'1'
        sbrc r27 ,4
        rjmp return_ascii ;
        ldi r24 ,'2'
        sbrc r27 ,5
        rjmp return_ascii
        ldi r24 ,'3' 
        sbrc r27 ,6
        rjmp return_ascii
        ldi r24 ,'A'
        sbrc r27 ,7
        rjmp return_ascii
        clr r24
        rjmp return_ascii
        return_ascii:
        pop r27 ; ????????? ???? ??????????? r27:r26
        pop r26
        ret 

	write_2_nibbles_sim:
        push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
        push r25 ; ?????????? ??? ???????????? ??????????????
        ldi r24 ,low(6000) ; ?????????
        ldi r25 ,high(6000)
        rcall wait_usec
        pop r25
        pop r24 ; ????? ????? ??????
        push r24 ; ??????? ?? 4 MSB
        in r25, PIND ; ??????????? ?? 4 LSB ??? ?? ?????????????
        andi r25, 0x0f ; ??? ?? ??? ????????? ??? ????? ??????????? ?????????
        andi r24, 0xf0 ; ????????????? ?? 4 MSB ???
        add r24, r25 ; ???????????? ?? ?? ???????????? 4 LSB
        out PORTD, r24 ; ??? ???????? ???? ?????
        sbi PORTD, PD3 ; ????????????? ?????? Enable ???? ????????? PD3
        cbi PORTD, PD3 ; PD3=1 ??? ???? PD3=0
        push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
        push r25 ; ?????????? ??? ???????????? ??????????????
        ldi r24 ,low(6000) ; ?????????
        ldi r25 ,high(6000)
        rcall wait_usec
        pop r25
        pop r24 ; ????? ????? ??????
        pop r24 ; ??????? ?? 4 LSB. ????????? ?? byte.
        swap r24 ; ????????????? ?? 4 MSB ?? ?? 4 LSB
        andi r24 ,0xf0 ; ??? ?? ??? ????? ???? ?????????????
        add r24, r25
        out PORTD, r24
        sbi PORTD, PD3 ; ???? ?????? Enable
        cbi PORTD, PD3
        ret

	lcd_data_sim:
        push r24
        push r25
        sbi PORTD,PD2
        rcall write_2_nibbles_sim
        ldi r24,43
        ldi r25,0
        rcall wait_usec
        pop r25
        pop r24
        ret

	lcd_command_sim:
        push r24 ; ?????????? ???? ??????????? r25:r24 ????? ????
        push r25 ; ????????? ???? ??? ???????
        cbi PORTD, PD2 ; ??????? ??? ?????????? ??????? (PD2=0)
        rcall write_2_nibbles_sim ; ???????? ??? ??????? ??? ??????? 39?sec
        ldi r24, 39 ; ??? ??? ?????????? ??? ????????? ??? ??? ??? ??????? ??? lcd.
        ldi r25, 0 ; ???.: ???????? ??? ???????, ?? clear display ??? return home,
        rcall wait_usec ; ??? ???????? ????????? ?????????? ??????? ????????.
        pop r25 ; ????????? ???? ??????????? r25:r24
        pop r24
        ret 

	lcd_init_sim:
        push r24 ; ?????????? ???? ??????????? r25:r24 ????? ????
        push r25 ; ????????? ???? ??? ???????

        ldi r24, 40 ; ???? ? ???????? ??? lcd ????????????? ??
        ldi r25, 0 ; ????? ??????? ??? ???? ??? ????????????.
        rcall wait_msec ; ??????? 40 msec ????? ???? ?? ???????????.
        ldi r24, 0x30 ; ?????? ????????? ?? 8 bit mode
        out PORTD, r24 ; ?????? ??? ???????? ?? ??????? ???????
        sbi PORTD, PD3 ; ??? ?? ?????????? ??????? ??? ???????
        cbi PORTD, PD3 ; ??? ??????, ? ?????? ???????????? ??? ?????
        ldi r24, 39
        ldi r25, 0 ; ??? ? ???????? ??? ?????? ????????? ?? 8-bit mode
        rcall wait_usec ; ??? ?? ?????? ??????, ???? ?? ? ???????? ???? ??????????
        ; ??????? 4 bit ?? ??????? ?? ?????????? 8 bit
        push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
        push r25 ; ?????????? ??? ???????????? ??????????????
        ldi r24,low(1000) ; ?????????
        ldi r25,high(1000)
        rcall wait_usec
        pop r25
        pop r24 ; ????? ????? ??????
        ldi r24, 0x30
        out PORTD, r24
        sbi PORTD, PD3
        cbi PORTD, PD3
        ldi r24,39
        ldi r25,0
        rcall wait_usec 
        push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
        push r25 ; ?????????? ??? ???????????? ??????????????
        ldi r24 ,low(1000) ; ?????????
        ldi r25 ,high(1000)
        rcall wait_usec
        pop r25
        pop r24 ; ????? ????? ??????
        ldi r24,0x20 ; ?????? ?? 4-bit mode
        out PORTD, r24
        sbi PORTD, PD3
        cbi PORTD, PD3
        ldi r24,39
        ldi r25,0
        rcall wait_usec
        push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
        push r25 ; ?????????? ??? ???????????? ??????????????
        ldi r24 ,low(1000) ; ?????????
        ldi r25 ,high(1000)
        rcall wait_usec
        pop r25
        pop r24 ; ????? ????? ??????
        ldi r24,0x28 ; ??????? ?????????? ???????? 5x8 ????????
        rcall lcd_command_sim ; ??? ???????? ??? ??????? ???? ?????
        ldi r24,0x0c ; ???????????? ??? ??????, ???????? ??? ???????
        rcall lcd_command_sim
        ldi r24,0x01 ; ?????????? ??? ??????
        rcall lcd_command_sim
        ldi r24, low(1530)
        ldi r25, high(1530)
        rcall wait_usec
        ldi r24 ,0x06 ; ???????????? ????????? ??????? ???? 1 ??? ??????????
        rcall lcd_command_sim ; ??? ????? ???????????? ???? ??????? ??????????? ???
        ; ?????????????? ??? ????????? ????????? ??? ??????
        pop r25 ; ????????? ???? ??????????? r25:r24
        pop r24
		ret
\end{minted}


\section*{2.C}
\subsection*{Σημειώσεις}
Στην C η λογική του προγράμματος είναι διαφορετική από αυτή του προγράμματος assembly. Εδώ η έξοδος στα LEDs δίνεται στην ρουτίνα εξυπηρέτησης του ADC.
\subsection*{Κώδικας}

\begin{minted}[linenos,frame=single,breaklines=true]{c}

#define F_CPU 8000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>


#define NOP() {__asm__ __volatile__("nop");}
	

int temp = 0x0000;
int t_flag = 0; // όταν είναι 0 βγαζει στην εξοδο 0, όταν είναι 1 βγάζει το επίπεδο του αερίου
int password = 0;//αν είναι 1 (σωστός κωδικός) κάνει το t_flag 1, για να μην αναβοσβήνουν τα 4 δευτερόλεπτα που η ειδική ομάδα είναι στην αίθουσα
int leds = 0x00, MSB_led = 0x00; //η κατάσταση του επιπέδου του αερίου και του MLSB της portb
 
ISR(TIMER1_OVF_vect) {
	TCCR1B = (1<<CS12)|(0<<CS11)|(1<<CS10);
	TCNT1 = 64755; //100ms
	ADCSRA |= (1<<ADSC);
	
	if(t_flag == 0)  t_flag = 1;	//ανα 100ms αλλάζουμε αυτήν την τιμή για να αναβοσβήσουμε τα led όταν το επίπεδο του αερίου ξεπεράσει τα όρια
	else t_flag = 0;
	if(password == 1) t_flag = 1; //σε περίπτωση σωστού κωδικού σταματάμε την εναλλαγή
}


//Απο τον τύπο Vgas = C*M + Vgas0 βρήκαμε οτι για C = 70ppm, Vgas = 1. 
//Επιπλέον η έξοδος του ADC είναι ADC = Vin * (1024/5) = 204.8*Vin, όπου Vin = Vgas. 
//Άρα, έχουμε συναγερμό για ADC>205
//Χωρίζουμε τα επίπεδα σε 7, άρα 1024/7 = 147 τιμές το επίπεδο

ISR(ADC_vect){
	if(ADC < 147) PORTB = 0x01 | (MSB_led << 7);
	else if(ADC >= 147 && ADC < 205) PORTB = 0x03 | (MSB_led << 7);
	else if(t_flag == 1){
		if(ADC >= 205 && ADC < 294) leds = 0x03;
		else if(ADC >= 294 && ADC < 441) leds = 0x07; 
		else if(ADC >= 441 && ADC < 588) leds = 0x0F;
		else if(ADC >= 588 && ADC < 735) leds = 0x1F;
		else if(ADC >= 735 && ADC < 882) leds = 0x3F;
		else if(ADC >= 882) leds = 0x7F;
		PORTB = leds | (MSB_led << 7);
	}
	else {
		PORTB = MSB_led << 7;
	}
}


void adc_init(){
	ADMUX = (1<<REFS0);
	ADCSRA = (1<<ADEN)|(1<<ADIE)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
}

int scan_row_sim(int r25) {
	PORTC = r25;
	int r24;
	_delay_us(500);
	NOP();
	NOP();
	r24 = PINC;
	r24 = r24 & 0x0F;
	return r24;

}

//a is LSB, b is MSB
void scan_keypad_sim(int *a, int *b) {
			
	int r25 = 0x10, r24, r27, r26;
	r24 = scan_row_sim(r25);
	r27 = ( (r24 & 0x0F) << 4 | (r24 & 0xF0) >> 4); //swap r24
	
	r25 = 0x20;
	r24 = scan_row_sim(r25);
	r27 += r24;
	
	r25 = 0x40;
	r24 = scan_row_sim(r25);
	r26 = ( (r24 & 0x0F) << 4 | (r24 & 0xF0) >> 4); //swap r24
	
	r25 = 0x80;
	r24 = scan_row_sim(r25);
	r26 += r24;
	*a = r26;
	*b = r27;
	
	PORTC = 0x00;
	return;
}

void scan_keypad_rising_edge_sim (int time, int *a, int *b) {
	int r22, r23, r24, r25;
	 int r26;
	scan_keypad_sim(&r24, &r25);
	_delay_ms(15);
	scan_keypad_sim(&r22, &r23);
	r24 = r24 & r22;
	r25 = r25 & r23;
	r26 = temp;
	r25 = r25 << 8;
	temp = r25 | r24;
	r26 = ~r26;
	*a = r24 & (r26 & 0x00FF);
	*b = (r25 >> 8) & ((r26 & 0xFF00) >> 8);
	
	
	return;
	}

int keypad_to_ascii_sim (int r24, int r25) {
	int r26 = '0';
	switch(r24) {
		case 0x01:
			r26 = '*';
			break;
		case 0x02:
			r26 = '0';
			break;
		case 0x04:
			r26 = '#';
			break;
		case 0x08:
			r26 = 'D';
			break;
		case 0x10:
			r26 = '7';
			break;
		case 0x20:
			r26 = '8';
			break;
		case 0x40:
			r26 = '9';
			break;
		case 0x80:
			r26 = 'C';
			break;
		}
	switch(r25) {
		case 0x01:
		r26 = '4';
		break;
		case 0x02:
		r26 = '5';
		break;
		case 0x04:
		r26 = '6';
		break;
		case 0x08:
		r26 = 'B';
		break;
		case 0x10:
		r26 = '1';
		break;
		case 0x20:
		r26 = '2';
		break;
		case 0x40:
		r26 = '3';
		break;
		case 0x80:
		r26 = 'A';
		break;
	}		

	return r26;
	
}

int main(void)
{
    DDRB = 0xFF;		//B as output
	DDRC = 0xF0;		//PC0-3 input and PC4-PC7 output (for the 4x4 keypad)
	adc_init();
	TIMSK = (1<<TOIE1);
	TCCR1B = (1<<CS12)|(0<<CS11)|(1<<CS10);
	TCNT1 = 64755;
	sei();
	/* Replace with your application code */
    while (1) 
    {
		 int  r24, r25, c1, c2;
		 
		 do {
			 scan_keypad_rising_edge_sim(15, &r24, &r25);
			 c1 = keypad_to_ascii_sim(r24, r25);
		 }
		 while(r24 == 0 && r25 == 0);	//while there is no pressed key, continue to scan if sth is pressed
		 do
		 {
			 scan_keypad_rising_edge_sim(15, &r24, &r25);
			 c2 = keypad_to_ascii_sim(r24, r25);
		 }
		 while(r24 == 0 && r25 == 0);	//continue scanning for the 2nd digit
		 if (c1 == '7' && c2 == '1') {	//if the digit were 7 and then 1
			 password = 1; //correct password
			 MSB_led = 1;				
			 PORTB = 0x80 | leds;				//switch on the PB7 and the state of the leds for 4 seconds
			 for(int i = 0; i < 190; i++) {	//for 4 seconds
				 scan_keypad_rising_edge_sim(15, &r24, &r25);	//while scanning also (required in the remote access program)
				 _delay_ms(1);
			 }
			 PORTB = 0x00 | leds;				//after the 4 seconds switch off the PB7
			 MSB_led = 0;
			 password = 0;
		 
		 }
		 else {							//if the digits were not 7 and 1
			 for (int i = 0; i < 4; i++) {	//switch on and off the leds 4 times
				 MSB_led = 1;
				 for(int i = 0; i < 35; i++) {	//for 0.5 sec each
					 scan_keypad_rising_edge_sim(15, &r24, &r25);	//while scanning (remote access program)
					 _delay_ms(1);
				 }
				 MSB_led = 0;
				 for(int i = 0; i < 35; i++) {
					 scan_keypad_rising_edge_sim(15, &r24, &r25);
					 _delay_ms(1);
				 }
				
			 }
		 }
		
    }
}

\end{minted}
\end{document}
